//! # Algorithm
//!
//! Find IDs in given ranges that are "doubled" (e.g., 1212) or "repeated" (e.g., 123123123).
//!
//! **Part 1 (doubled)**: Check if first half equals second half. Arithmetic approach
//! (~5x faster than string) uses `id / divisor == id % divisor`.
//!
//! **Part 2 (repeated)**: Three approaches implemented:
//! - *Multiplication*: build test number by repeating pattern, compare to original
//! - *Division*: break down number chunk by chunk, verify each matches pattern
//! - *Generative* (~40% faster): generate repeated sequences directly using a
//!   "repetition generator" (e.g., 1001001) instead of testing every number

use std::collections::HashSet;
use std::fs;
use std::ops::RangeInclusive;

use anyhow::{Context, Result};

type IdFilter = std::iter::Filter<RangeInclusive<u64>, fn(&u64) -> bool>;

pub fn find_sum_of_invalid_ids<I>(
    id_ranges: impl IntoIterator<Item = RangeInclusive<u64>>,
    find_invalid: impl Fn(RangeInclusive<u64>) -> I,
) -> u128
where
    I: IntoIterator<Item = u64>,
{
    id_ranges
        .into_iter()
        .flat_map(find_invalid)
        .map(u128::from)
        .sum()
}

/// Wraps a predicate to filter IDs from a range.
pub fn filter_by(predicate: fn(&u64) -> bool) -> impl Fn(RangeInclusive<u64>) -> IdFilter {
    move |range| range.filter(predicate)
}

/// Uses arithmetic to check if an ID is a doubled sequence.
/// Benchmarked ~5x faster than string comparison due to avoiding allocation.
pub fn is_doubled_sequence(id: &u64) -> bool {
    if *id == 0 {
        return false;
    }
    let digits = id.ilog10() + 1;
    if !digits.is_multiple_of(2) {
        return false;
    }
    let divisor = 10u64.pow(digits / 2);
    id / divisor == id % divisor
}

/// Alternative: uses string comparison to check if an ID is a doubled sequence.
pub fn is_doubled_sequence_string(id: &u64) -> bool {
    let s = id.to_string();
    if !s.len().is_multiple_of(2) {
        return false;
    }
    let (left, right) = s.split_at(s.len() / 2);
    left == right
}

/// Checks if an ID is a repeated sequence (at least twice).
/// Uses multiplication to build up test numbers rather than division to break down.
/// Benchmarked ~54% faster than the division approach.
pub fn is_repeated_sequence(id: &u64) -> bool {
    if *id == 0 {
        return false;
    }
    let digits = id.ilog10() + 1;

    (1..=digits / 2)
        .filter(|seq_len| digits.is_multiple_of(*seq_len))
        .any(|seq_len| {
            let seq_len_shift = 10u64.pow(seq_len);
            let sequence = id / 10u64.pow(digits - seq_len);

            let test_number =
                (1..digits / seq_len).fold(sequence, |aggr, _| aggr * seq_len_shift + sequence);
            test_number == *id
        })
}

/// Alternative: uses division to break down the number and check each chunk.
pub fn is_repeated_sequence_div(id: &u64) -> bool {
    if *id == 0 {
        return false;
    }
    let digits = id.ilog10() + 1;

    (1..=digits / 2)
        .filter(|seq_len| digits.is_multiple_of(*seq_len))
        .any(|seq_len| {
            let base = 10u64.pow(seq_len);
            let pattern = id % base;
            let mut remaining = *id;
            while remaining > 0 {
                if remaining % base != pattern {
                    return false;
                }
                remaining /= base;
            }
            true
        })
}

/// Alternative: generate repeated sequences directly within range bounds
/// instead of testing every number in the range. Returns a hash set of found IDs to ensure uniqueness.
/// For example, the patterns "1" and "11" can both generate the repeated sequence "1111".
/// Benchmarked ~40% faster than the iterative approach on example ranges.
pub fn find_repeated_sequences_in_range(range: RangeInclusive<u64>) -> HashSet<u64> {
    let (start, end) = (*range.start(), *range.end());
    if start == 0 {
        return HashSet::new();
    }

    // idea: repeated sequences can be generated by finding all possible patterns for a specific sequence length and
    // multiplying with a repetition generator (e.g., 123 * 1001001 = 123123123). Avoid as much work
    // as possible by preemptively filtering out patterns
    // that would produce values outside the range.

    let min_digits = start.ilog10() + 1;
    let max_digits = end.ilog10() + 1;

    (min_digits..=max_digits)
        .flat_map(|total_digits| {
            // because the pattern must repeat in its entirety,
            // the total digits must be a multiple of the pattern length and the pattern length
            // can't exceed half the total digits
            (1..=total_digits / 2)
                .filter(move |pattern_len| total_digits.is_multiple_of(*pattern_len))
                .map(move |pattern_len| (total_digits, pattern_len))
        })
        .flat_map(|(total_digits, pattern_len)| {
            let min_pattern = 10u64.pow(pattern_len - 1); // e.g., 100 for 3 digits
            let max_pattern = 10u64.pow(pattern_len) - 1; // e.g., 999 for 3 digits

            // 10^total_digits - 1 gives all 9s (e.g., 999999 for 6 digits)
            // Dividing by max_pattern gives 1s spaced by 0s (e.g., 999999 / 999 = 1001)
            let repetition_generator = (10u64.pow(total_digits) - 1) / max_pattern;

            let pattern_lower = start.div_ceil(repetition_generator);
            let pattern_upper = end / repetition_generator;

            // when the range spans multiple magnitudes, either start or end may not match the total digits
            // of the current iteration, so we need to clamp the pattern accordingly
            let pattern_start = min_pattern.max(pattern_lower);
            let pattern_end = max_pattern.min(pattern_upper);

            (pattern_start..=pattern_end).map(move |pattern| pattern * repetition_generator)
        })
        .collect()
}

pub fn read_id_ranges(path: &str) -> Result<Vec<RangeInclusive<u64>>> {
    fs::read_to_string(path)?
        .trim()
        .split(',')
        .map(|range| {
            let (start, end) = range.split_once('-').context("invalid range format")?;
            let start = start.parse().context("invalid start")?;
            let end = end.parse().context("invalid end")?;
            Ok(start..=end)
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use std::ops::RangeInclusive;

    use crate::{
        filter_by, find_repeated_sequences_in_range, find_sum_of_invalid_ids, is_doubled_sequence,
        is_doubled_sequence_string, is_repeated_sequence, is_repeated_sequence_div,
    };

    const EXAMPLE_RANGES: [RangeInclusive<u64>; 11] = [
        11..=22,
        95..=115,
        998..=1012,
        1188511880..=1188511890,
        222220..=222224,
        1698522..=1698528,
        446443..=446449,
        38593856..=38593862,
        565653..=565659,
        824824821..=824824827,
        2121212118..=2121212124,
    ];

    #[test]
    fn part1_arithmetic() {
        let sum = find_sum_of_invalid_ids(EXAMPLE_RANGES, filter_by(is_doubled_sequence));
        assert_eq!(sum, 1227775554);
    }

    #[test]
    fn part1_string() {
        let sum = find_sum_of_invalid_ids(EXAMPLE_RANGES, filter_by(is_doubled_sequence_string));
        assert_eq!(sum, 1227775554);
    }

    #[test]
    fn part2_mul() {
        let sum = find_sum_of_invalid_ids(EXAMPLE_RANGES, filter_by(is_repeated_sequence));
        assert_eq!(sum, 4174379265);
    }

    #[test]
    fn part2_div() {
        let sum = find_sum_of_invalid_ids(EXAMPLE_RANGES, filter_by(is_repeated_sequence_div));
        assert_eq!(sum, 4174379265);
    }

    #[test]
    fn part2_generative() {
        let sum = find_sum_of_invalid_ids(EXAMPLE_RANGES, find_repeated_sequences_in_range);
        assert_eq!(sum, 4174379265);
    }
}
